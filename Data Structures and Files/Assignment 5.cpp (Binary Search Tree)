#include<iostream>
#include "queue.h"
using namespace std;
class tree_Node
{
public:
	int data;
	tree_Node *left,*right;
public:
	tree_Node()
	{
		left=NULL;
		right=NULL;
	}
};
class tree
{
	tree_Node *root;
	void destroy(tree_Node*);
	void pre_disp(tree_Node*);
	void in_disp(tree_Node*);
	void post_disp(tree_Node*);
	tree_Node* copy(tree_Node*);
public:
	void insert(int);
	void create(void);
	void pre_disp();
	void in_disp();
	void post_disp();
	int search(int);
	void BFT();
	void mirror(tree);
	void del(int);
	int smallest(void);
	int largest(void);
	int is_empty();
	void destroy();
	tree()
	{
		root=NULL;
	}
	~tree()
	{
		destroy(root);
	}
};
void tree::destroy(tree_Node *rt)
{
	if(rt!=NULL)
	{
		destroy(rt->left);
		destroy(rt->right);
		delete rt;
	}
}
void tree::destroy()
{
	destroy(root);
	root=NULL;
}
void tree::pre_disp(tree_Node *root)
{
	if(root != NULL)
	{
		cout<<root -> data<<",";
		pre_disp(root -> left);
		pre_disp(root ->right);
	}
}
void tree::in_disp(tree_Node *root)
{
	if(root != NULL)
	{
		in_disp(root -> left);
		cout<<root -> data<<",";
		in_disp(root ->right);
	}
}
void tree::post_disp(tree_Node *root)
{
	if(root != NULL)
	{
		post_disp(root -> left);
		post_disp(root ->right);
		cout<<root -> data<<",";
	}
}
void tree::insert(int new_data)
{
	tree_Node *temp,*pwalk,*parent;
	temp=new tree_Node;
	temp->data=new_data;
	if(root==NULL)
		root=temp;
	else
	{
		pwalk=root;
		while(pwalk!=NULL)
		{
			parent=pwalk;
			if(temp->data<pwalk->data)
				pwalk=pwalk->left;
			else if(temp->data>pwalk->data)
				pwalk=pwalk->right;
			else
				break;
		}
		if(pwalk==parent)
			cout<<"The data already exists!!\n";
		else if(temp->data<parent->data)
			parent->left=temp;
		else
			parent->right=temp;
	}
}
void tree::create()
{
	int ch,data;
	do
	{
		cout<<"Do you wish to add Node\n1:Yes\n2:No\nEnter choice:";
		cin>>ch;
		if(ch==1)
		{
			cout<<"Enter data:";
			cin>>data;
			insert(data);
		}
		else if(ch!=2)
			cout<<"Wrong choice!!\n";
	}while(ch!=2);
}
void tree::pre_disp()
{
	pre_disp(root);
}
void tree::in_disp()
{
	in_disp(root);
}
void tree::post_disp()
{
	post_disp(root);
}
int tree::search(int key)
{
	tree_Node *pwalk;
	pwalk=root;
	while(pwalk!=NULL)
	{
		if(pwalk->data==key)
			return 1;
		else if(key<pwalk->data)
			pwalk=pwalk->left;
		else
			pwalk=pwalk->right;
	}
	return 0;
}
void tree::BFT()
{
	tree_Node *dis;
	queue<tree_Node>Q;
	if(root!=NULL)
		Q.insert(*root);
	while(!Q.is_empty())
	{
		dis=Q.remove();
		cout<<dis->data<<",";
		if(dis->left!=NULL)
			Q.insert(*dis->left);
		if(dis->right!=NULL)
			Q.insert(*dis->right);
	}
}
tree_Node* tree::copy(tree_Node* rt)
{
	tree_Node* tr=new tree_Node;
	tr->data=rt->data;
	if(rt->left!=NULL)
		tr->left=copy(rt->left);
	if(rt->right!=NULL)
		tr->right=copy(rt->right);
	return tr;
}
void tree::mirror(tree tr)
{
	tree_Node *dis,*temp;
	queue<tree_Node*>Q;
	root=copy(tr.root);
	if(root!=NULL)
		Q.insert(root);
	while(!Q.is_empty())
	{
		dis=*Q.remove();
		temp=dis->left;
		dis->left=dis->right;
		dis->right=temp;
		if(dis->left!=NULL)
			Q.insert(dis->left);
		if(dis->right!=NULL)
			Q.insert(dis->right);
	}
	tr.root=NULL;
}
void tree::del(int key)
{
	int flag=0,data;
	tree_Node *pwalk,*parent,*p,*pre;
	pwalk=root;
	while(parent!=NULL && flag==0)
	{
		if(pwalk->data==key)
			flag=1;
		else if(pwalk->data>key)
		{
			parent=pwalk;
			pwalk=pwalk->left;
		}
		else
		{
			parent=pwalk;
			pwalk=pwalk->right;
		}
	}
	if(flag==0)
	{
		cout<<"Data not found!!";
		return;
	}
	else if(pwalk->left==NULL && pwalk->right==NULL)
	{
		if(pwalk==root)
		{
			root=NULL;
		}
		else
		{
			if(pwalk==parent->left)
				parent->left=NULL;
			else
				parent->right=NULL;
		}
		delete pwalk;
	}
	else if(pwalk->left==NULL)
	{
		if(pwalk==root)
		{
			root=pwalk->right;
		}
		else
		{
			if(parent->left==pwalk)
				parent->left=pwalk->right;
			else
				parent->right=pwalk->right;
		}
		delete pwalk;
	}
	else if(pwalk->right==NULL)
	{
		if(pwalk==root)
		{
			root=pwalk->left;
		}
		else
		{
			if(parent->left==pwalk)
				parent->left=pwalk->left;
			else
				parent->right=pwalk->left;
		}
		delete pwalk;
	}
	else
	{
		pre=pwalk;
		p=pwalk->right;
		while(p->left!=NULL)
		{
			pre=p;
			p=p->left;
		}
		data=p->data;
		if(pre==pwalk)
		{
			if(p->right==NULL)
			{
				pre->right=NULL;
				delete p;
			}
			else
			{
				pre->right=p->right;
				delete p;
			}
		}
		else if(p->right==NULL)
		{
			pre->left=NULL;
			delete p;
		}
		else
		{
			pre->left=p->right;
			delete p;
		}
		pwalk->data=data;
	}
	cout<<"Data has been deleted!!";
}
int tree::smallest()
{
	tree_Node* small;
	small=root;
	while(small->left!=NULL)
	{
		small=small->left;
	}
	return small->data;
}
int tree::largest()
{
	tree_Node* large;
	large=root;
	while(large->right!=NULL)
	{
		large=large->right;
	}
	return large->data;
}
int tree::is_empty()
{
	if(root==NULL)
		return 1;
	else return 0;
}
int main()
{
	int choice,data,res;
	tree T,M;
	do
	{
		while(T.is_empty())
		{
			cout<<"\nYou need to create tree first!!\n";
			T.create();
		}
		cout<<"\n-----------------------BINARY SEARCH TREE----------------------------\n";
		cout<<"What do you wish to do?\n1:Insert\n2:Search\n3:Delete\n4:Display\n5:BFT\n";
		cout<<"6:Mirror Image\n7:Smallest element\n8:Largest element\n9:Exit\nEnter choice:";
		cin>>choice;
		switch(choice)
		{
			case 1:cout<<"Enter data to be inserted:";
				cin>>data;
				T.insert(data);
				break;
			case 2:cout<<"Enter data to be searched:";
				cin>>data;
				res=T.search(data);
				if(res==0)
					cout<<data<<" is not in the tree!!";
				else
					cout<<data<<" is found in the tree!!";
				break;
			case 3:cout<<"Enter data to be deleted:";
				cin>>data;
				T.del(data);
				break;
			case 4:cout<<"Preorder traversal:\n\t";
				T.pre_disp();
				cout<<"\nInorder traversal:\n\t";
				T.in_disp();
				cout<<"\nPostorder traversal:\n\t";
				T.post_disp();
				break;
			case 5:cout<<"Breadth First Traversal of the tree is:\n\t";
				T.BFT();
				break;
			case 6:M.destroy();
				M.mirror(T);
				cout<<"Preorder traversal of mirror image:\n\t";
				M.pre_disp();
				cout<<"\nInorder traversal of mirror image:\n\t";
				M.in_disp();
				cout<<"\nPostorder traversal of mirror image:\n\t";
				M.post_disp();
				break;
			case 7:res=T.smallest();
				cout<<"Smallest element is:"<<res;
				break;
			case 8:res=T.largest();
				cout<<"Largest element is:"<<res;
				break;
			case 9:cout<<"Thank You!!\n";
				break;
			default:cout<<"Wrong choice!!";
		}
	}while(choice!=9);
	return 0;
}
